#!/bin/bash

function help() {
  # Prints help to console
  exitStatus="0"
  [ -n "$1" ] && exitStatus="$1"

  echo "Usage: $0 [-h] [-f] [-d] [-m NUM] action dir"
  echo "-h      ... prints this message"
  echo "-f      ... forces actions, does not ask for deletion confirmation"
  echo "-m NUM  ... keep max last NUM of backups, delete older"
  echo "action  ... prepare | finish | delete"
  echo "            - prepare  ... creates new directory and in-progress link"
  echo "            - finish   ... changes latest to in-progress and deletes old backups (in max backups is specified)"
  echo "            - delete   ... deletes old backups (in max backups is specified)"
  echo "dir     ... directory in which the backup will be created"

  exit "$exitStatus"
}

# Parse command line arguments
maxBackups="INF"
actionForce="0"

while getopts ":hfm:" o; do
  case "${o}" in
  m)
    maxBackups="$OPTARG"
    { [ -n "$maxBackups" ] && [ "$maxBackups" -eq "$maxBackups" ]; } || help 1
    ;;
  f)
    actionForce="1"
    ;;
  h)
    help
    ;;
  *)
    help 1
    ;;
  esac
done
shift $((OPTIND - 1))

action="$1"
backupRootDir="$2"

[[ "$action" != "prepare" ]] && [[ "$action" != "finish" ]] && [[ "$action" != "delete" ]] && help 1
[ -z "$backupRootDir" ] && help 1

function fail() {
  # Prints error to stderr and exits with status 1
  echo "ERR: $1" >&2
  exit 1
}

function q-yes-no() {
  # Yes/no question
  question="$1"
  while true; do
    read -rp "$question [y/n]: " r
    case "$r" in
    [Yy]*) return 0 ;;
    [Nn]*)
      echo "Aborted"
      return 1
      ;;
    esac
  done
}

function backup-prepare() {
  cd "$backupRootDir" || fail "Cannot cd to $backupRootDir"
  echo "Working in $backupRootDir"

  backupDir="$(date +'%Y%m%d-%H%M%S')"
  [ -e "$backupDir" ] && fail "$backupDir already exists!"

  # Test if already in-progress
  if [ -e "in-progress" ]; then
    if [ "$actionForce" -eq "1" ]; then
      echo "Force deleting in-progress"
      target="$(readlink 'in-progress')" || fail "Could not read in-progress target"
      rm -rf "$target" || fail "Failed to remove in-progress files (folder $target)"
      rm -f "in-progress" || fail "Failed to remove in-progress link"
    else
      fail "Link in-progress found, please investigate"
    fi
  fi

  # Create new backup directory
  echo "Creating new backup dir $backupDir"
  mkdir "$backupDir" || fail "Could not create backup link"
  echo "Creating working link 'in-progress' to $backupDir"
  ln -s "$backupDir" "in-progress"
  # shellcheck disable=SC2166
  if [ -e "latest" -o -L "latest" ]; then
    echo "Copying from latest to in-progress"
    latest="$(readlink 'latest')" || fail "Could not read latest target"
    cp -lPr "$latest/." "in-progress/" || fail "Copying last latest failed"
  else
    echo "First init, nothing to copy"
  fi
  echo "Backup preparation done"
}

function backup-finish() {
  # Replace latest with in-progress
  cd "$backupRootDir" || fail "Cannot cd to $backupRootDir"
  echo "Working in $backupRootDir"
  [ ! -e "in-progress" ] && fail "No in-progress folder found, nothing to finish"
  [ -e "latest" ] && { rm "latest" || fail "Could not remove latest link"; }
  mv "in-progress" "latest" || fail "Could move move in-progress to latest"
  echo "Backup finished"
}

function backup-delete-old() {
  cd "$backupRootDir" || fail "Cannot cd to $backupRootDir"

  # Deletes old backup so to keep up to "$maxBackups" backups
  if [[ "$maxBackups" == "INF" ]]; then
    # keep infinity backups
    return
  fi
  # shellcheck disable=SC2010
  backupDates="$(ls -d -- */ | grep -E "[0-9]{8}-[0-9]{6}" | sed -Ee 's|^(.*)/$|\1|' | sort)" || fail "Cannot find backup dates"
  backupsCount="$(echo "$backupDates" | wc -l)"
  echo "Found $backupsCount backups, maximum is $maxBackups"

  if [ "$backupsCount" -le "$maxBackups" ]; then
    return
  fi

  backupsToDelete="$(echo "$backupDates" | head -n "-${maxBackups}")"
  backupsToKeep="$(echo "$backupDates" | tail -n "${maxBackups}")"
  echo "Will delete following backups:"
  echo "$backupsToDelete" | sed -Ee "s/^(.*)$/- \1/"
  echo "And keep:"
  echo "$backupsToKeep" | sed -Ee "s/^(.*)$/- \1/"

  [ "$actionForce" -eq "1" ] || q-yes-no "Do you want to delete old backups?" || {
    exit 2
  }

  echo "Deleting old backups:"
  while read -r folder; do
    echo -n "- $folder ... "
    rm -rf "$folder" || fail "Could not delete"
    echo "done"
  done <<<"$backupsToDelete"
}

case "$action" in
  prepare)
    (backup-prepare)
    ;;
  finish)
    (backup-finish) &&
    (backup-delete-old)
    ;;
  delete)
    (backup-delete-old)
    ;;
esac
